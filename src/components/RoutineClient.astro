---
---

<script>
	const dateKey = new Date().toISOString().slice(0, 10);
	const storageKey = `routine-progress-${dateKey}`;
	const prefsKey = 'routine-preferences';
	const cards = Array.from(document.querySelectorAll('[data-exercise-id]'));
	const sections = Array.from(document.querySelectorAll('[data-section-id]'));
	const totalExerciseNodes = Array.from(document.querySelectorAll('[data-total-exercises]'));
	const summaryLinks = Array.from(document.querySelectorAll('[data-summary-link]'));
	const customSectionCounts = Array.from(document.querySelectorAll('[data-custom-section-count]'));
	const customItems = Array.from(document.querySelectorAll('[data-custom-item]'));
	const customLists = Array.from(document.querySelectorAll('[data-custom-list]'));
	const customizationKey = 'routine-customization-v1';

	const stateByCard = new Map();
	let currentCard = null;
	let guidedMode = false;

	const progressCount = document.querySelector('[data-progress-count]');
	const progressTotal = document.querySelector('[data-progress-total]');
	const progressFill = document.querySelector('[data-progress-fill]');

	const sectionPanel = document.querySelector('[data-sections-panel]');
	const sectionOverlay = document.querySelector('[data-sections-overlay]');
	const sectionToggle = document.querySelector('[data-sections-toggle]');
	const backToTop = document.querySelector('[data-back-to-top]');

	const guidedToggle = document.querySelector('[data-guided-toggle]');
	const filterPending = document.querySelector('[data-filter-pending]');
	const soundToggle = document.querySelector('[data-sound-toggle]');
	const vibrationToggle = document.querySelector('[data-vibration-toggle]');

	const nowPlaying = document.querySelector('[data-now-playing]');
	const nowTitle = document.querySelector('[data-now-title]');
	const nowTimer = document.querySelector('[data-now-timer]');
	const nowStart = document.querySelector('[data-now-start]');
	const nowToggle = document.querySelector('[data-now-toggle]');
	const nowDone = document.querySelector('[data-now-done]');
	const nowNext = document.querySelector('[data-now-next]');
	const toastContainer = document.querySelector('[data-toast-container]');

	const guidedOverlay = document.querySelector('[data-guided-overlay]');
	const guidedCard = document.querySelector('[data-guided-card]');
	const guidedImage = document.querySelector('[data-guided-image]');
	const guidedTitle = document.querySelector('[data-guided-title]');
	const guidedMeta = document.querySelector('[data-guided-meta]');
	const guidedTimer = document.querySelector('[data-guided-timer]');
	const guidedProgress = document.querySelector('[data-guided-progress]');
	const guidedIndex = document.querySelector('[data-guided-index]');
	const guidedClose = document.querySelector('[data-guided-close]');
	const guidedStart = document.querySelector('[data-guided-start]');
	const guidedNext = document.querySelector('[data-guided-next]');
	const guidedDone = document.querySelector('[data-guided-done]');
	const guidedPause = document.querySelector('[data-guided-pause]');

	const loadProgress = () => {
		try {
			return JSON.parse(localStorage.getItem(storageKey) || '{}');
		} catch {
			return {};
		}
	};

	const saveProgress = (data) => {
		localStorage.setItem(storageKey, JSON.stringify(data));
	};

	const loadPrefs = () => {
		try {
			return JSON.parse(localStorage.getItem(prefsKey) || '{}');
		} catch {
			return {};
		}
	};

	const savePrefs = (prefs) => {
		localStorage.setItem(prefsKey, JSON.stringify(prefs));
	};

	const getDefaultOrder = () => {
		const order = {};
		sections.forEach((section) => {
			const sectionId = section.dataset.sectionId;
			const list = section.querySelector('[data-section-list]');
			if (!sectionId || !list) return;
			order[sectionId] = Array.from(list.querySelectorAll('[data-exercise-id]')).map(
				(card) => card.dataset.exerciseId
			);
		});
		return order;
	};

	const loadCustomization = () => {
		try {
			return JSON.parse(localStorage.getItem(customizationKey) || '{}');
		} catch {
			return {};
		}
	};

	let customization = loadCustomization();
	let customOrder = customization.order || getDefaultOrder();
	let customDisabled = customization.disabled || {};

	const saveCustomization = () => {
		localStorage.setItem(
			customizationKey,
			JSON.stringify({ order: customOrder, disabled: customDisabled })
		);
	};

	const isDisabled = (card) => Boolean(customDisabled[card.dataset.exerciseId]);

	const getOrderedCards = () =>
		Array.from(document.querySelectorAll('[data-section-list] [data-exercise-id]'));

	const getActiveCards = () => getOrderedCards().filter((card) => !isDisabled(card));

	const prefs = loadPrefs();
	const doneMap = loadProgress().done || {};
	guidedMode = Boolean(prefs.guidedMode);

	const formatTime = (value) => {
		const minutes = Math.floor(value / 60);
		const seconds = value % 60;
		return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
	};

	const showToast = (message, tone = 'info') => {
		if (!toastContainer) return;
		const toast = document.createElement('div');
		const color =
			tone === 'success'
				? 'border-emerald-400/50 text-emerald-200'
				: tone === 'warn'
					? 'border-amber-300/50 text-amber-200'
					: 'border-slate-700/50 text-slate-200';
		toast.className = `rounded-xl border bg-slate-950/90 px-4 py-3 text-xs uppercase tracking-[0.2em] ${color}`;
		toast.textContent = message;
		toastContainer.appendChild(toast);
		setTimeout(() => toast.remove(), 2500);
	};

	const getDefaultRest = (card) => {
		const raw = Number(card.dataset.rest || '0');
		return Number.isFinite(raw) && raw > 0 ? raw : 30;
	};

	const getState = (card) => {
		if (!stateByCard.has(card)) {
			stateByCard.set(card, {
				remaining: 0,
				running: false,
				intervalId: null,
				selected: getDefaultRest(card),
				wasComplete: false,
				notified: false,
				startAt: null,
				duration: null,
				rafId: null,
				autoAdvanced: false,
			});
		}
		return stateByCard.get(card);
	};

	const setFormVisibility = () => {
		cards.forEach((card) => {
			const disabled = isDisabled(card);
			card.classList.toggle('is-custom-hidden', disabled);
			if (disabled) return;
			if (!filterPending || !filterPending.checked) {
				card.classList.remove('is-hidden');
				return;
			}
			const done = Boolean(doneMap[card.dataset.exerciseId]);
			card.classList.toggle('is-hidden', done);
		});
	};

	const reorderList = (container, order, selector) => {
		if (!container || !order?.length) return;
		const items = Array.from(container.querySelectorAll(selector));
		const itemMap = new Map(items.map((item) => [item.dataset.exerciseId, item]));
		order.forEach((id) => {
			const item = itemMap.get(id);
			if (item) container.appendChild(item);
		});
		items.forEach((item) => {
			if (!order.includes(item.dataset.exerciseId)) container.appendChild(item);
		});
	};

	const applyCustomization = () => {
		sections.forEach((section) => {
			const sectionId = section.dataset.sectionId;
			const list = section.querySelector('[data-section-list]');
			if (!sectionId || !list) return;
			const order = customOrder[sectionId];
			if (!order || order.length === 0) {
				customOrder[sectionId] = Array.from(list.querySelectorAll('[data-exercise-id]')).map(
					(card) => card.dataset.exerciseId
				);
				return;
			}
			reorderList(list, order, '[data-exercise-id]');
			Array.from(list.querySelectorAll('[data-exercise-id]')).forEach((card, index) => {
				const badge = card.querySelector('[data-exercise-order]');
				if (badge) badge.textContent = `#${index + 1}`;
			});
		});

		customLists.forEach((list) => {
			const sectionId = list.dataset.sectionId;
			const order = customOrder[sectionId];
			reorderList(list, order, '[data-custom-item]');
		});

		cards.forEach((card) => {
			card.classList.toggle('is-custom-hidden', isDisabled(card));
		});

		customItems.forEach((item) => {
			const checkbox = item.querySelector('[data-custom-toggle]');
			const disabled = Boolean(customDisabled[item.dataset.exerciseId]);
			if (checkbox) checkbox.checked = !disabled;
			item.classList.toggle('opacity-60', disabled);
		});

		updateProgress();
		setFormVisibility();
		if (currentCard && isDisabled(currentCard)) {
			const next = getNextCard(currentCard, true) || getPrevCard(currentCard, true);
			if (next) setCurrentCard(next, guidedMode, 'next');
		}
	};

	const updateGuidedOverlay = () => {
		if (!guidedOverlay || !currentCard) return;
		const img = currentCard.querySelector('img');
		if (guidedImage && img) {
			guidedImage.src = img.src;
			guidedImage.alt = img.alt || '';
		}
		if (guidedTitle) guidedTitle.textContent = currentCard.querySelector('h3')?.textContent || '';
		if (guidedMeta) {
			const meta = currentCard.querySelectorAll('dd');
			const sets = meta[0]?.textContent || '';
			const reps = meta[1]?.textContent || '';
			const rest = meta[2]?.textContent || '';
			guidedMeta.textContent = `Series ${sets} · Reps ${reps} · Descanso ${rest}`;
		}
		const ordered = getActiveCards();
		const index = ordered.indexOf(currentCard) + 1;
		if (guidedIndex) guidedIndex.textContent = `${index}/${ordered.length}`;
		const state = getState(currentCard);
		if (guidedTimer) guidedTimer.textContent = formatTime(state.remaining);
		updateGuidedProgress(currentCard);
	};

	const updateGuidedProgress = (card) => {
		if (!guidedProgress) return;
		const state = getState(card);
		const total = state.duration || state.selected || getDefaultRest(card);
		const progress = total ? ((total - state.remaining) / total) * 100 : 0;
		guidedProgress.style.width = `${Math.min(Math.max(progress, 0), 100)}%`;
	};

	const startProgressLoop = (card) => {
		const state = getState(card);
		if (state.rafId) cancelAnimationFrame(state.rafId);
		const total = state.duration || state.selected || getDefaultRest(card);
		const tick = () => {
			if (!state.running) return;
			const elapsed = (Date.now() - state.startAt) / 1000;
			const progress = total ? Math.min(elapsed / total, 1) : 0;
			if (guidedProgress) guidedProgress.style.width = `${progress * 100}%`;
			state.rafId = requestAnimationFrame(tick);
		};
		state.rafId = requestAnimationFrame(tick);
	};

	const animateGuided = (direction = 'next') => {
		if (!guidedCard) return;
		const offset = direction === 'next' ? -24 : 24;
		guidedCard.animate(
			[
				{ transform: `translateY(${offset}px)`, opacity: 0.5 },
				{ transform: 'translateY(0)', opacity: 1 },
			],
			{ duration: 320, easing: 'cubic-bezier(0.2, 0.8, 0.2, 1)' }
		);
	};

	const setCurrentCard = (card, shouldScroll = false, direction = 'next') => {
		if (card && isDisabled(card)) return;
		if (currentCard) currentCard.classList.remove('is-current');
		currentCard = card;
		if (currentCard) currentCard.classList.add('is-current');
		updateNowBar();
		updateGuidedOverlay();
		if (guidedMode) animateGuided(direction);
		if (shouldScroll && currentCard && !guidedMode) {
			currentCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
		}
	};

	const updateNowBar = () => {
		if (!nowPlaying) return;
		if (!currentCard || guidedMode) {
			nowPlaying.classList.add('hidden');
			return;
		}
		nowPlaying.classList.remove('hidden');
		if (nowTitle) nowTitle.textContent = currentCard.querySelector('h3')?.textContent || '';
		const state = getState(currentCard);
		if (nowTimer) nowTimer.textContent = formatTime(state.remaining);
	};

	const updateProgress = () => {
		const activeCards = getActiveCards();
		const activeIds = new Set(activeCards.map((card) => card.dataset.exerciseId));
		const doneCount = Object.keys(doneMap).filter((id) => activeIds.has(id)).length;
		const totalCount = activeCards.length;

		totalExerciseNodes.forEach((node) => {
			node.textContent = `${totalCount}`;
		});
		if (progressCount) progressCount.textContent = `${doneCount}`;
		if (progressTotal) progressTotal.textContent = `${totalCount}`;
		if (progressFill) {
			const ratio = totalCount ? (doneCount / totalCount) * 100 : 0;
			progressFill.style.width = `${ratio}%`;
		}

		sections.forEach((section) => {
			const sectionId = section.dataset.sectionId;
			const sectionCards = cards.filter(
				(card) => card.dataset.sectionId === sectionId && !isDisabled(card)
			);
			const total = sectionCards.length;
			const done = sectionCards.filter((card) => doneMap[card.dataset.exerciseId]).length;
			const target = section.querySelector('[data-section-progress]');
			const bar = section.querySelector('[data-section-progress-bar]');
			const count = section.querySelector('[data-section-count]');
			if (target) target.textContent = `${done}/${total} hechos`;
			if (bar) bar.style.width = `${total ? (done / total) * 100 : 0}%`;
			if (count) count.textContent = `${total} ejercicios`;

			const summaryLink = summaryLinks.find((link) => link.dataset.summaryId === sectionId);
			const summaryCount = summaryLink?.querySelector('[data-summary-count]');
			if (summaryCount) summaryCount.textContent = `${total} ejercicios`;
		});

		customSectionCounts.forEach((node) => {
			const sectionId = node.dataset.sectionId;
			const active = cards.filter(
				(card) => card.dataset.sectionId === sectionId && !isDisabled(card)
			).length;
			node.textContent = `${active} activos`;
		});
	};

	const setDoneState = (card, done) => {
		const id = card.dataset.exerciseId;
		const checkbox = card.querySelector('[data-done-checkbox]');
		card.classList.toggle('is-done', done);
		if (checkbox) checkbox.checked = done;
		if (done) {
			doneMap[id] = true;
		} else {
			delete doneMap[id];
		}
		saveProgress({ done: doneMap });
		setFormVisibility();
		updateProgress();
		if (guidedMode && done) {
			const next = getNextCard(card, true);
			if (next) setCurrentCard(next, true);
		}
	};

	const notifyComplete = () => {
		if (soundToggle?.checked) {
			const ctx = new (window.AudioContext || window.webkitAudioContext)();
			const osc = ctx.createOscillator();
			const gain = ctx.createGain();
			osc.type = 'sine';
			osc.frequency.value = 880;
			gain.gain.value = 0.1;
			osc.connect(gain);
			gain.connect(ctx.destination);
			osc.start();
			setTimeout(() => {
				osc.stop();
				ctx.close();
			}, 300);
		}
		if (vibrationToggle?.checked && 'vibrate' in navigator) {
			navigator.vibrate(200);
		}
		showToast('Descanso completo', 'success');
	};

	const updateTimerUI = (card) => {
		const timer = card.querySelector('[data-timer]');
		const display = card.querySelector('[data-timer-display]');
		const status = card.querySelector('[data-timer-status]');
		const startBtn = card.querySelector('[data-action="start"]');
		const toggleBtn = card.querySelector('[data-action="toggle"]');
		const resetBtn = card.querySelector('[data-action="reset"]');
		const doneCta = card.querySelector('[data-action="mark-done"]');
		const state = getState(card);

		if (display) display.textContent = formatTime(state.remaining);
		if (toggleBtn) {
			toggleBtn.textContent = state.running ? 'Pausar' : 'Reanudar';
			toggleBtn.disabled = state.remaining === 0;
		}
		if (resetBtn) resetBtn.disabled = state.remaining === 0 && !state.running;
		if (startBtn) startBtn.disabled = state.running;
		if (timer) timer.classList.toggle('is-complete', state.remaining === 0 && !state.running && state.wasComplete);

		if (status) status.textContent = state.remaining === 0 && state.wasComplete ? 'Descanso completo' : '';
		if (doneCta) doneCta.hidden = !(state.remaining === 0 && state.wasComplete);
		if (state.wasComplete && !state.notified) {
			state.notified = true;
			notifyComplete();
			if (guidedMode && !state.autoAdvanced) {
				state.autoAdvanced = true;
				setTimeout(() => {
					scrollToNext(card);
				}, 700);
			}
		}
		if (currentCard === card) updateNowBar();
		if (guidedMode && currentCard === card) updateGuidedOverlay();
	};

	const startTimer = (card) => {
		const state = getState(card);
		if (state.running) return;
		if (state.remaining === 0) state.remaining = state.selected || getDefaultRest(card);
		state.duration = state.remaining;
		state.startAt = Date.now();
		state.running = true;
		state.wasComplete = false;
		state.notified = false;
		state.autoAdvanced = false;
		updateTimerUI(card);
		if (guidedMode && currentCard === card) startProgressLoop(card);
		state.intervalId = window.setInterval(() => {
			state.remaining -= 1;
			if (state.remaining <= 0) {
				state.remaining = 0;
				state.running = false;
				state.wasComplete = true;
				window.clearInterval(state.intervalId);
				state.intervalId = null;
				if (state.rafId) cancelAnimationFrame(state.rafId);
				state.rafId = null;
			}
			updateTimerUI(card);
		}, 1000);
	};

	const toggleTimer = (card) => {
		const state = getState(card);
		if (state.running) {
			state.running = false;
			window.clearInterval(state.intervalId);
			state.intervalId = null;
			if (state.rafId) cancelAnimationFrame(state.rafId);
			state.rafId = null;
		} else if (state.remaining > 0) {
			state.running = true;
			const total = state.duration || state.selected || getDefaultRest(card);
			state.startAt = Date.now() - (total - state.remaining) * 1000;
			state.intervalId = window.setInterval(() => {
				state.remaining -= 1;
				if (state.remaining <= 0) {
					state.remaining = 0;
					state.running = false;
					state.wasComplete = true;
					window.clearInterval(state.intervalId);
					state.intervalId = null;
					if (state.rafId) cancelAnimationFrame(state.rafId);
					state.rafId = null;
				}
				updateTimerUI(card);
			}, 1000);
			if (guidedMode && currentCard === card) startProgressLoop(card);
		}
		updateTimerUI(card);
	};

	const resetTimer = (card) => {
		const state = getState(card);
		state.running = false;
		state.remaining = 0;
		state.wasComplete = false;
		state.notified = false;
		state.autoAdvanced = false;
		window.clearInterval(state.intervalId);
		state.intervalId = null;
		if (state.rafId) cancelAnimationFrame(state.rafId);
		state.rafId = null;
		updateTimerUI(card);
	};

	const selectRest = (card, value) => {
		const state = getState(card);
		state.selected = value;
		state.remaining = 0;
		state.wasComplete = false;
		state.notified = false;
		state.autoAdvanced = false;
		state.duration = value;
		state.startAt = null;
		if (state.rafId) cancelAnimationFrame(state.rafId);
		state.rafId = null;
		const options = card.querySelectorAll('[data-rest-option]');
		options.forEach((btn) => {
			btn.classList.toggle('is-active', Number(btn.dataset.restOption) === value);
		});
		updateTimerUI(card);
	};

	const getNextCard = (card, pendingOnly) => {
		const ordered = getActiveCards();
		const index = ordered.indexOf(card);
		if (index === -1) return null;
		for (let step = 1; step <= ordered.length; step += 1) {
			const next = ordered[(index + step) % ordered.length];
			if (!pendingOnly) return next;
			if (!doneMap[next.dataset.exerciseId]) return next;
		}
		return null;
	};

	const getPrevCard = (card, pendingOnly) => {
		const ordered = getActiveCards();
		const index = ordered.indexOf(card);
		if (index === -1) return null;
		for (let step = 1; step <= ordered.length; step += 1) {
			const prev = ordered[(index - step + ordered.length) % ordered.length];
			if (!pendingOnly) return prev;
			if (!doneMap[prev.dataset.exerciseId]) return prev;
		}
		return null;
	};

	const scrollToNext = (card) => {
		const next = getNextCard(card, guidedMode || filterPending?.checked);
		if (!next) return;
		setCurrentCard(next, guidedMode, 'next');
	};

	const scrollToPrev = (card) => {
		const prev = getPrevCard(card, guidedMode || filterPending?.checked);
		if (!prev) return;
		setCurrentCard(prev, guidedMode, 'prev');
	};

	const openSectionsPanel = () => {
		if (sectionPanel) sectionPanel.hidden = false;
		sectionPanel?.classList.remove('hidden');
		sectionOverlay?.classList.remove('pointer-events-none', 'opacity-0');
		sectionOverlay?.classList.add('pointer-events-auto', 'opacity-100');
		if (sectionToggle) sectionToggle.setAttribute('aria-expanded', 'true');
	};

	const closeSectionsPanel = () => {
		if (sectionPanel) sectionPanel.hidden = true;
		sectionPanel?.classList.add('hidden');
		sectionOverlay?.classList.remove('pointer-events-auto', 'opacity-100');
		sectionOverlay?.classList.add('pointer-events-none', 'opacity-0');
		if (sectionToggle) sectionToggle.setAttribute('aria-expanded', 'false');
	};

	const initPrefs = () => {
		if (filterPending) filterPending.checked = Boolean(prefs.filterPending);
		if (soundToggle) soundToggle.checked = Boolean(prefs.sound);
		if (vibrationToggle) vibrationToggle.checked = Boolean(prefs.vibration);
		if (guidedToggle) guidedToggle.setAttribute('data-guided-active', guidedMode ? 'true' : 'false');
		setFormVisibility();
	};

	const showGuidedOverlay = () => {
		if (!guidedOverlay) return;
		guidedOverlay.classList.remove('hidden');
		guidedOverlay.setAttribute('aria-hidden', 'false');
		document.body.classList.add('overflow-hidden');
		updateGuidedOverlay();
	};

	const hideGuidedOverlay = () => {
		if (!guidedOverlay) return;
		guidedOverlay.classList.add('hidden');
		guidedOverlay.setAttribute('aria-hidden', 'true');
		document.body.classList.remove('overflow-hidden');
	};

	cards.forEach((card) => {
		const id = card.dataset.exerciseId;
		const checkbox = card.querySelector('[data-done-checkbox]');
		selectRest(card, getDefaultRest(card));
		if (checkbox) checkbox.checked = Boolean(doneMap[id]);
		card.classList.toggle('is-done', Boolean(doneMap[id]));
		updateTimerUI(card);
	});

	initPrefs();
	applyCustomization();

	const activateGuidedMode = () => {
		guidedMode = true;
		prefs.guidedMode = true;
		savePrefs(prefs);
		guidedToggle?.classList.add('ring-2', 'ring-amber-300/60');
		const ordered = getActiveCards();
		const firstPending = ordered.find((card) => !doneMap[card.dataset.exerciseId]);
		if (ordered.length > 0) setCurrentCard(firstPending || ordered[0], true);
		showGuidedOverlay();
		showToast('Modo guiado activo', 'warn');
	};

	const deactivateGuidedMode = () => {
		guidedMode = false;
		prefs.guidedMode = false;
		savePrefs(prefs);
		guidedToggle?.classList.remove('ring-2', 'ring-amber-300/60');
		hideGuidedOverlay();
		updateNowBar();
		showToast('Modo guiado desactivado');
	};

	document.addEventListener('change', (event) => {
		const checkbox = event.target.closest('[data-done-checkbox]');
		if (checkbox) {
			const card = checkbox.closest('[data-exercise-id]');
			if (!card) return;
			setDoneState(card, checkbox.checked);
			return;
		}

		if (event.target.closest('[data-filter-pending]')) {
			prefs.filterPending = filterPending?.checked;
			savePrefs(prefs);
			setFormVisibility();
			return;
		}

		if (event.target.closest('[data-sound-toggle]')) {
			prefs.sound = soundToggle?.checked;
			savePrefs(prefs);
			return;
		}

		if (event.target.closest('[data-vibration-toggle]')) {
			prefs.vibration = vibrationToggle?.checked;
			savePrefs(prefs);
			return;
		}

		const customToggle = event.target.closest('[data-custom-toggle]');
		if (customToggle) {
			const item = customToggle.closest('[data-custom-item]');
			if (!item) return;
			const id = item.dataset.exerciseId;
			if (customToggle.checked) delete customDisabled[id];
			else customDisabled[id] = true;
			saveCustomization();
			applyCustomization();
		}
	});

	document.addEventListener('click', (event) => {
		const customMove = event.target.closest('[data-custom-move]');
		if (customMove) {
			const item = customMove.closest('[data-custom-item]');
			if (!item) return;
			const sectionId = item.dataset.sectionId;
			const id = item.dataset.exerciseId;
			const order = customOrder[sectionId] || getDefaultOrder()[sectionId] || [];
			const index = order.indexOf(id);
			if (index === -1) return;
			if (customMove.dataset.customMove === 'up' && index > 0) {
				[order[index - 1], order[index]] = [order[index], order[index - 1]];
			}
			if (customMove.dataset.customMove === 'down' && index < order.length - 1) {
				[order[index + 1], order[index]] = [order[index], order[index + 1]];
			}
			customOrder[sectionId] = order;
			saveCustomization();
			applyCustomization();
			return;
		}

		if (event.target.closest('[data-custom-reset]')) {
			customDisabled = {};
			customOrder = getDefaultOrder();
			saveCustomization();
			applyCustomization();
			showToast('Personalizacion reiniciada');
			return;
		}

		const restOption = event.target.closest('[data-rest-option]');
		if (restOption) {
			const card = restOption.closest('[data-exercise-id]');
			if (card) selectRest(card, Number(restOption.dataset.restOption));
			return;
		}

		const action = event.target.closest('[data-action]');
		if (action) {
			const card = action.closest('[data-exercise-id]');
			const type = action.dataset.action;
			if (!card) return;
			setCurrentCard(card);
			if (type === 'start') startTimer(card);
			if (type === 'toggle') toggleTimer(card);
			if (type === 'reset') resetTimer(card);
			if (type === 'next') scrollToNext(card);
			if (type === 'mark-done') setDoneState(card, true);
			return;
		}

		if (event.target.closest('[data-reset-today]')) {
			Object.keys(doneMap).forEach((key) => delete doneMap[key]);
			saveProgress({ done: doneMap });
			cards.forEach((card) => setDoneState(card, false));
			showToast('Progreso reiniciado');
			return;
		}

		if (event.target.closest('[data-guided-toggle]')) {
			if (guidedMode) deactivateGuidedMode();
			else activateGuidedMode();
			return;
		}

		if (event.target.closest('[data-guided-close]')) {
			deactivateGuidedMode();
			return;
		}

		if (event.target.closest('[data-guided-start]')) {
			if (currentCard) startTimer(currentCard);
			return;
		}

		if (event.target.closest('[data-guided-pause]')) {
			if (currentCard) toggleTimer(currentCard);
			return;
		}

		if (event.target.closest('[data-guided-next]')) {
			if (currentCard) scrollToNext(currentCard);
			return;
		}

		if (event.target.closest('[data-guided-done]')) {
			if (currentCard) setDoneState(currentCard, true);
			return;
		}

		if (event.target.closest('[data-sections-toggle]')) {
			if (sectionPanel?.hidden) openSectionsPanel();
			else closeSectionsPanel();
			return;
		}

		if (event.target.closest('[data-sections-overlay]')) {
			closeSectionsPanel();
			return;
		}

		if (event.target.closest('[data-sections-panel] a')) {
			closeSectionsPanel();
			return;
		}

		if (event.target.closest('[data-back-to-top]')) {
			window.scrollTo({ top: 0, behavior: 'smooth' });
			return;
		}

		const cardClick = event.target.closest('[data-exercise-id]');
		if (cardClick) {
			setCurrentCard(cardClick);
		}

		if (event.target.closest('[data-now-start]')) {
			if (currentCard) startTimer(currentCard);
		}
		if (event.target.closest('[data-now-toggle]')) {
			if (currentCard) toggleTimer(currentCard);
		}
		if (event.target.closest('[data-now-done]')) {
			if (currentCard) setDoneState(currentCard, true);
		}
		if (event.target.closest('[data-now-next]')) {
			if (currentCard) scrollToNext(currentCard);
		}
	});

	document.addEventListener('keydown', (event) => {
		const target = event.target;
		if (target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName)) return;
		if (!currentCard) return;
		if (event.code === 'Space') {
			event.preventDefault();
			const state = getState(currentCard);
			if (state.running || state.remaining > 0) toggleTimer(currentCard);
			else startTimer(currentCard);
		}
		if (event.key === 'n' || event.key === 'N') {
			scrollToNext(currentCard);
		}
		if (event.key === 'ArrowUp') {
			scrollToPrev(currentCard);
		}
		if (event.key === 'ArrowDown') {
			scrollToNext(currentCard);
		}
		if (event.key === 'h' || event.key === 'H') {
			setDoneState(currentCard, true);
		}
		if (event.key === 'g' || event.key === 'G') {
			if (guidedMode) deactivateGuidedMode();
			else activateGuidedMode();
		}
		if (event.key === 'p' || event.key === 'P') {
			if (filterPending) {
				filterPending.checked = !filterPending.checked;
				prefs.filterPending = filterPending.checked;
				savePrefs(prefs);
				setFormVisibility();
			}
		}
	});

	if (guidedMode) activateGuidedMode();

	let touchStartY = 0;
	let touchStartX = 0;
	let touchActive = false;

	guidedOverlay?.addEventListener('touchstart', (event) => {
		const touch = event.touches[0];
		touchStartY = touch.clientY;
		touchStartX = touch.clientX;
		touchActive = true;
	});

	guidedOverlay?.addEventListener('touchend', (event) => {
		if (!touchActive || !currentCard) return;
		touchActive = false;
		const touch = event.changedTouches[0];
		const deltaY = touch.clientY - touchStartY;
		const deltaX = touch.clientX - touchStartX;
		if (Math.abs(deltaY) < 40 || Math.abs(deltaY) < Math.abs(deltaX)) return;
		if (deltaY < 0) {
			scrollToNext(currentCard);
		} else {
			scrollToPrev(currentCard);
		}
	});

	const handleScroll = () => {
		if (!backToTop) return;
		const visible = window.scrollY > 400;
		backToTop.classList.toggle('opacity-100', visible);
		backToTop.classList.toggle('pointer-events-auto', visible);
		backToTop.classList.toggle('-translate-y-1', visible);
		backToTop.classList.toggle('opacity-0', !visible);
		backToTop.classList.toggle('pointer-events-none', !visible);
	};

	handleScroll();
	window.addEventListener('scroll', handleScroll, { passive: true });
</script>
